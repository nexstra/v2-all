plugins {
  id "org.ajoberstar.grgit" version "3.0.0-rc.2"
}
ext {
  dirs=["core-dsl","content-services","docstore","maildb", "nconn-v2","portal-sys","odd","cds","aws-utils" ,"docker-utils"]//,"nconn-legacy"]
  tcServer = "http://build.nexstra.com:8111"
  download="${tcServer}/guestAuth/repository/download"
  commitAll = project.hasProperty("commitAll")
}
apply plugin: 'java'

//artifacts/docstore-lib/build/libs/docstore-lib-1.4.44
repositories {
  ivy {
    ivyPattern      "${download}/[module]/[revision]/teamcity-ivy.xml"
    artifactPattern "${download}/[module]/[revision]/[artifact](.[ext])"
  }
/*
  maven {url "${download}/CloudwatchLog4j_BuildLib/.lastSuccessful/artifacts.zip!"}
  maven{  url "${download}/CoreDsl_BuildLib/.lastSuccessful/artifacts.zip!"}
 maven {  url "${download}/Docstore_BuildLib/.lastSuccessful/artifacts.zip!"}
maven { url "${download}/Maildb_MailRouter/.lastSuccessful/artifacts.zip!"}
maven { url "${download}/NconnV2_BuildLib/.lastSuccessful/artifacts.zip!"}
    maven { url "${download}/Maildb_BuildLib/.lastSuccessful/artifacts.zip!"}
*/
    jcenter()
}

build {
  doLast {
   dirs.each { 
    def d=it
     exec { 
       commandLine "/bin/sh" , "-c" , "cd ../${d}/; [ -x ./getrepo.sh ] && ./getrepo.sh ; ./gradlew build publish"
      }
  }
  }
}

task appRun {
  gradle.includedBuilds.each {
    logger.info(it.projectDir)
    if( it.task(":appRun") != null)
      dependsOn it.task(":appRun")
  }}
task appRunDebug {
  gradle.includedBuilds.each {
    logger.info(it.projectDir)
    if( it.task(":appRunDebug") != null)
      dependsOn it.task(":appRunDebug")
  }}
task publish { 
  gradle.includedBuilds.each {
    logger.info(it.projectDir)
    if( it.task(":publish") != null)
      dependsOn it.task(":publish")
  }

}

import org.ajoberstar.grgit.Grgit
def workOn( repo ) {
  def d = "${projectDir}/../${repo}"
  try { return Grgit.open(dir: d ) } catch( e) { }  
  return Grgit.clone( dir:d , uri : "git@github.com:nexstra/${repo}.git") 
}
def printStatus(s,n){
   logger.info("\t$n: added: ${s.added.size()} modified: ${s.modified.size()}, removed: ${s.removed.size()}")
}
def printAllStatus(d,s){
     logger.quiet("\t$d dirty: ${!s.clean}")
     logger.quiet("\tconflicts: ${s.conflicts.size()}") 
     printStatus(s.staged,"staged")
     printStatus(s.unstaged,"unstaged")
}

def initApps( verbose ) {
     def clean =0
     def dirty=0
     dirs.each {
        def g = workOn(it)
        if( verbose ) { 
          def s = g.status()
           
          logger.quiet(  "$it: ${g.describe()}  clean: ${s.clean}" )
          printAllStatus(it,s)
          if( s.clean ) clean++ else dirty++
        }
     }
    if(verbose)
      logger.quiet("\tclean: $clean dirty: $dirty")
 }
task appsInit {
  doLast {
    initApps( false )
   }
}

task appsStatus( group: 'build'){
  doLast {
    initApps( true )
   }
}


task appsList {
  group = 'info'
   doLast { 
      dirs.each { println(it)  }
   } 
}
  
task appsPull {
  dependsOn appsInit
  group = 'build'
  doLast {
     dirs.each {
        def g = workOn(it)
        g.pull()
    }
  }
}

task appsCommit {
  ext.commitComment =  "Update"
  dependsOn appsInit
  group = 'build'
  doLast {
     dirs.each {
        def g = workOn(it)
        g.commit {
             all =  project.commitAll 
             message  = commitComment 
      } 
    }
  }
}
task appsPush {
  ext.commitComment =  "Update"
  dependsOn appsInit
  group = 'build'
  doLast {
     dirs.each {
        def g = workOn(it)
        g.push()
       
     } 
  }
}
def scanBuilds()
{
  def buildTypes = [:]

  dirs.each {
    def proj = it
    def d = "${projectDir}/../${it}/.teamcity"
    fileTree(d) {
      include '*/buildTypes/*.xml'
    }.files.each {
      def buildType = it.name.substring(0, it.name.length() - 4)
      if(! ( buildType.contains("Rpms") || buildType.contains("Overrides" )|| buildType.contains("Portal")||buildType.contains("ECR") ))
      buildTypes[proj] = buildType
    }
  }
  logger.info("returning buildTypes: ${buildTypes}")
  return buildTypes

}

task buildTypes(type:WriteProperties) {
  group='build'
  outputFile = file("build/buildtypes.txt")
  outputs.upToDateWhen { false }
  doFirst {
    properties scanBuilds()
    
  }
}

ext.artifactVersion="lastSuccessful"
logger.info("----")
logger.info("----")
dependencies {
  scanBuilds().each { k,v->
   logger.info("build: $v")
  //["docstore" : "Docstore_BuildLib"] .each { k,v -> 
    compile("org:$v:$artifactVersion") {
      artifact {
        name = 'publications.versions'
        type = 'properties'
      }
    }
  }
}

task downloadArtifacts( type: Copy ) {
  group "download"
  outputs.upToDateWhen { false }
  //from configurations.compile
  doFirst {
  configurations.compile.getResolvedConfiguration().each {
     it.getFirstLevelModuleDependencies().each {  
       it.getModuleArtifacts().each {
       def id = it.getModuleVersion()
        def build = id.id.name
        from it.file
       into "${project.buildDir}/${build}/"
    rename {
      it.replace '-lastSuccessful',''
     }  
        
   }
  }
   }
}
/*
  configurations.compile.each {
    logger.info("configuring $it")
    from file(it) 
    //from zipTree( file(it ) )
    into "${ project.projectDir }/repo"
  }
*/
  eachFile {
    logger.info("downloading $it")
  }
}

task printDirs {
  group = 'info'
  doLast {
  dirs.each { 
     println( it + "\t" + file("../$it"))
    }
  }
}
